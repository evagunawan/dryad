#!/usr/bin/env python3
#Author: Kelsey Florek
#email: kelsey.florek@slh.wisc.edu
#description: A pipeline for constructing SNP based and reference free phylogenies

import subprocess as sub
import sys, os, time, argparse, datetime
import docker
import multiprocessing as mp
from shutil import copyfile

#local libraries
from app.lib import cpu_count, checkexists, check_update_status
from app.trimming import q_trim
from app.core_genome import core_genome

#determine command line arguments and get path
parser = argparse.ArgumentParser(description='A pipeline for constructing SNP based and reference free phylogenies.')
parser.add_argument('reads', type=str,help="text file listing the location of paired reads to be included in the analysis")
parser.add_argument('-o',metavar='output', type=str,help="output directory - defaults to working directory")
parser.add_argument('-c', action='store_const',help="construct core genome reference free maximum likelihood phylogenetic tree",const=True,default=False)
parser.add_argument('-s', action='store_const',help="create SNP tree using Lyve-SET",const=True,default=False)
parser.add_argument('-f',metavar='reference', type=str,help="reference fasta for SNP tree")
parser.add_argument('-t',metavar='threads', type=int,help="number of cpus to use for pipeline",default=4)

if len(sys.argv[1:]) == 0:
    parser.print_help()
    parser.exit()
args = parser.parse_args()

try:
    reference = os.path.abspath(args.f)
except (AttributeError, TypeError) as err:
    reference = False

threads = args.t
snp = args.s
core = args.c
reads_path = args.reads

if core == False and snp == False:
    parser.print_help()
    sys.exit()

if snp == True and reference == False:
    print("SNP pipeline needs a reference: [-f]")
    sys.exit()

#get current working dir if output is empty
try:
    out = os.path.abspath(args.o)
except (AttributeError, TypeError) as err:
    out = os.getcwd()

#open file and pull locations into a list
with open(reads_path,'r') as f:
    r_list = []
    for line in f:
        if line.strip() != '':
            r_list.append(line.strip())

#sort and join pairs
r_list.sort()
if len(r_list) % 2 != 0:
    print('There is an uneven number of read pairs in the read list. Exiting.')
    sys.exit()
paired_reads = []
[paired_reads.append([x,y]) for x,y in zip(r_list[0::2],r_list[1::2])]

#get num of jobs and number of cpus per job
jobs,cpu_job = cpu_count(threads)

#check to see if an unfinished job exists
status = 0
status,outdir = check_update_status(out)
if status:
    print("There is a previous unfinished run, do you wish to continue?")
    continue_run = input("Y/N? ")
    if continue_run == 'n' or continue_run == 'N':
        status = 0
        outdir = ''
    elif continue_run == 'y' or continue_run == 'Y':
        pass
    else:
        print("Not a Y/N, exiting!")
        sys.exit()

if status == 0:
    #create output dir
    time = datetime.datetime.now()
    str_time = "{0}{1}{2}{3}{4}".format(time.year,time.month,time.day,time.hour,time.minute)
    if checkexists(os.path.join(out,"dryad-"+str_time)):
        print(os.path.join(out,"dryad-"+str_time)+" already exists... exiting.")
        sys.exit()
    outdir = os.path.join(out,"dryad-"+str_time)
    check_update_status(outdir,"1")
    status = 1

if status == 1:
    #start trimming
    status = q_trim(paired_reads,jobs,cpu_job,outdir)
    check_update_status(outdir,"2")
    status = 2

if status == 2:
    #start core-genome pipeline
    core_genome(jobs,cpu_job,outdir)

#start snp pipeline
